{"language": "Vyper", "sources": {".venv/lib/python3.13/site-packages/snekmate/auth/ownable.vy": {"content": "# pragma version ~=0.4.1\n\"\"\"\n@title Owner-Based Access Control Functions\n@custom:contract-name ownable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement a basic access\n        control mechanism, where there is an account (an owner)\n        that can be granted exclusive access to specific functions.\n        By default, the owner account will be the one that deploys\n        the contract. This can later be changed with `transfer_ownership`.\n        An exemplary integration can be found in the ERC-20 implementation here:\n        https://github.com/pcaversaccio/snekmate/blob/main/src/snekmate/tokens/erc20.vy.\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/access/Ownable.sol.\n\"\"\"\n\n\n# @dev Returns the address of the current owner.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\nowner: public(address)\n\n\n# @dev Emitted when the ownership is transferred\n# from `previous_owner` to `new_owner`.\nevent OwnershipTransferred:\n    previous_owner: indexed(address)\n    new_owner: indexed(address)\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    @notice The `owner` role will be assigned to\n            the `msg.sender`.\n    \"\"\"\n    self._transfer_ownership(msg.sender)\n\n\n@external\ndef transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice Note that this function can only be\n            called by the current `owner`. Also,\n            the `new_owner` cannot be the zero address.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    self._check_owner()\n    assert new_owner != empty(address), \"ownable: new owner is the zero address\"\n    self._transfer_ownership(new_owner)\n\n\n@external\ndef renounce_ownership():\n    \"\"\"\n    @dev Leaves the contract without an owner.\n    @notice Renouncing ownership will leave the\n            contract without an owner, thereby\n            removing any functionality that is\n            only available to the owner.\n    \"\"\"\n    self._check_owner()\n    self._transfer_ownership(empty(address))\n\n\n@internal\ndef _check_owner():\n    \"\"\"\n    @dev Throws if the sender is not the owner.\n    \"\"\"\n    assert msg.sender == self.owner, \"ownable: caller is not the owner\"\n\n\n@internal\ndef _transfer_ownership(new_owner: address):\n    \"\"\"\n    @dev Transfers the ownership of the contract\n         to a new account `new_owner`.\n    @notice This is an `internal` function without\n            access restriction.\n    @param new_owner The 20-byte address of the new owner.\n    \"\"\"\n    old_owner: address = self.owner\n    self.owner = new_owner\n    log OwnershipTransferred(previous_owner=old_owner, new_owner=new_owner)\n", "sha256sum": "a4387a6dd5ab046ceff107e159f401f39a5813f4cb01a9ae556bc2c9fa710900"}, ".venv/lib/python3.13/site-packages/snekmate/utils/pausable.vy": {"content": "# pragma version ~=0.4.1\n\"\"\"\n@title Pausable Functions\n@custom:contract-name pausable\n@license GNU Affero General Public License v3.0 only\n@author pcaversaccio\n@notice These functions can be used to implement an emergency stop\n        mechanism that can be triggered by an authorised account.\n        Please note that this contract does not include an access\n        control mechanism (e.g., `ownable`) for triggering the emergency\n        stop. Such functionality must be implemented by the importing\n        contract, for instance (to avoid any NatSpec parsing error,\n        no `@` character is added to the visibility decorator `@external`\n        in the following example; please add them accordingly):\n        ```vy\n        from snekmate.auth import ownable\n        initializes: ownable\n\n        from snekmate.utils import pausable\n        initializes: pausable\n\n        exports: ...\n\n        ...\n\n        external\n        def pause():\n            ownable._check_owner()\n            pausable._pause()\n\n        external\n        def unpause():\n            ownable._check_owner()\n            pausable._unpause()\n        ```\n\n        The implementation is inspired by OpenZeppelin's implementation here:\n        https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/utils/Pausable.sol.\n\"\"\"\n\n\n# @dev Returns whether the contract is paused or not.\n# @notice If you declare a variable as `public`,\n# Vyper automatically generates an `external`\n# getter function for the variable.\npaused: public(bool)\n\n\n# @dev Emitted when `account` initiated the pause.\nevent Paused:\n    account: address\n\n\n# @dev Emitted when `account` lifted the pause.\nevent Unpaused:\n    account: address\n\n\n@deploy\n@payable\ndef __init__():\n    \"\"\"\n    @dev To omit the opcodes for checking the `msg.value`\n         in the creation-time EVM bytecode, the constructor\n         is declared as `payable`.\n    \"\"\"\n    pass\n\n\n@internal\ndef _pause():\n    \"\"\"\n    @dev Triggers the pause state. Note that the contract\n         must not be paused.\n    @notice This is an `internal` function without access\n            restriction.\n    \"\"\"\n    self._require_not_paused()\n    self.paused = True\n    log Paused(account=msg.sender)\n\n\n@internal\ndef _unpause():\n    \"\"\"\n    @dev Lifts the pause state. Note that the contract\n         must be paused.\n    @notice This is an `internal` function without access\n            restriction.\n    \"\"\"\n    self._require_paused()\n    self.paused = False\n    log Unpaused(account=msg.sender)\n\n\n@internal\ndef _require_not_paused():\n    \"\"\"\n    @dev Throws if the contract is paused.\n    \"\"\"\n    assert not self.paused, \"pausable: contract is paused\"\n\n\n@internal\ndef _require_paused():\n    \"\"\"\n    @dev Throws if the contract is not paused.\n    \"\"\"\n    assert self.paused, \"pausable: contract is not paused\"\n", "sha256sum": "ef0cc3e9aedae0071dc745eecdb913093d2d29a806f49514611b5f2c8a377052"}, "src/send_and_receive_editions.vy": {"content": "# pragma version 0.4.1\n\n\"\"\"\n@title Send & Receive Editions\n@author Transient Labs\n@license AGPL-3.0-only\n@custom:version 1.0.0\n@notice Contract that receives ERC-1155 editions and in exchange, sends a single new edition to the sender.\n@dev The contract is written to only be configured for a single output token, however multiple input token configurations are possible.\n     For each token sent out, you can configure which token and what amount of that token is required.\n     Example: token A can be redeemed by sending 2 of token B *or* 5 of token C.\n     It is not possible to combine different input tokens with this contract. This is a design choice to enhance simplicity.\n     Additionally, it is possible to cnfigure when the redemption opens and what supply there is of the redepmption token.\n\"\"\"\n\nfrom ethereum.ercs import IERC165\nfrom snekmate.auth import ownable\nfrom snekmate.utils import pausable\n\ninitializes: ownable\ninitializes: pausable\nimplements: IERC165\nexports: ownable.__interface__\n\n# Interfaces\ninterface IERC1155TL:\n    def externalMint(token_id: uint256, addresses: DynArray[address, 200], amounts: DynArray[uint256, 200]): nonpayable\n    def safeBatchTransferFrom(from_: address, to_: address, ids: DynArray[uint256, 200], values: DynArray[uint256, 200], data: Bytes[1024]): nonpayable\n\n# Structs\nstruct InitConfig:\n    contract_address: address\n    token_id: uint256\n    open_at: uint256\n    max_supply: uint256\n\nstruct InputConfig:\n    contract_address: address\n    token_id: uint256\n    amount: uint256\n\nstruct SettingsConfig:\n    open_at: uint256\n    max_supply: uint256\n\n# Events\nevent InputConfigured:\n    contract_address: indexed(address)\n    token_id: indexed(uint256)\n    amount: indexed(uint256)\n\n# Constants\nSUPPORTED_INTERFACES: constant(bytes4[2]) = [\n    0x01FFC9A7, # the ERC-165 identifier for ERC-165.\n    0x4E2312E0, # the ERC-165 identifier for ERC-155 Receiver.\n]\n\n# Storage\ncontract_address: public(address)\ntoken_id: public(uint256)\nopen_at: public(uint256)\nmax_supply: public(uint256)\nnum_redeemed: public(uint256)\ninput_amounts: HashMap[address, HashMap[uint256, uint256]] # input contract address + input token id -> input amount needed\n\n@deploy\ndef __init__(init_config: InitConfig):\n    ownable.__init__()\n    pausable.__init__()\n\n    self.contract_address = init_config.contract_address\n    self.token_id = init_config.token_id\n    self.open_at = init_config.open_at\n    self.max_supply = init_config.max_supply\n\n\n@external\n@nonreentrant\ndef onERC1155Received(operator: address, from_: address, id: uint256, value_: uint256,  data: Bytes[1024]) -> bytes4:\n    \"\"\"\n    @notice Function called when an ERC-1155 token is transferred to this contract. This handles the redemption. \n    @dev Requires the contract not to be paused\n    \"\"\"\n    pausable._require_not_paused()\n\n    self.process_input_token(msg.sender, id, value_, from_)\n\n    return method_id(\"onERC1155Received(address,address,uint256,uint256,bytes)\", output_type=bytes4)\n\n\n@external\n@nonreentrant\ndef onERC1155BatchReceived(\n    operator: address,\n    from_: address,\n    ids: DynArray[uint256, 200],\n    values: DynArray[uint256, 200],\n    data: Bytes[1024],\n) -> bytes4:\n    \"\"\"\n    @notice Function called when a batch of ERC-1155 tokens are transferred to this contract. This handles the redemption.\n    @dev Requires the contract not to be paused\n    \"\"\"\n    pausable._require_not_paused()\n\n    assert len(ids) == len(values), \"mismatch in ids array and values array\"\n    for i: uint256 in range(len(ids), bound=200):\n        self.process_input_token(msg.sender, ids[i], values[i], from_)\n\n    return method_id(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\", output_type=bytes4)\n    \n\n@internal\ndef process_input_token(input_contract_address: address, input_token_id: uint256, input_amount: uint256, recipient: address):\n    \"\"\"\n    @notice Helper function to process an input token\n    \"\"\"\n    # Make sure that the redemption is open\n    assert block.timestamp >= self.open_at, \"send_and_receive_editions: redemption not open\"\n\n    # Get input amount needed to redeem\n    required_input_amount: uint256 = self.input_amounts[input_contract_address][input_token_id]\n    assert required_input_amount > 0, \"send_and_receive_editions: invalid input token\"\n    assert input_amount == required_input_amount, \"send_and_receive_editions: invalid amount of token sent\"\n\n    # Make sure there is enough supply remaining\n    assert self.num_redeemed < self.max_supply, \"send_and_receive_editions: no supply remaining\"\n\n    # Adjust supply by one\n    self.num_redeemed += 1\n\n    # Mint token\n    output_contract: IERC1155TL = IERC1155TL(self.contract_address)\n    addresses: DynArray[address, 200] = [recipient]\n    amounts: DynArray[uint256, 200] = [1]\n    extcall output_contract.externalMint(self.token_id, addresses, amounts)\n\n\n@external\ndef config_inputs(configs: DynArray[InputConfig, 100]):\n    \"\"\"\n    @notice Function to set input amounts\n    @dev Requires the owner to call the function\n    \"\"\"\n    ownable._check_owner()\n\n    for config: InputConfig in configs:\n        self.input_amounts[config.contract_address][config.token_id] = config.amount\n        log InputConfigured(\n            contract_address=config.contract_address, \n            token_id=config.token_id,\n            amount=config.amount\n        )\n\n@external\ndef config_settings(config: SettingsConfig):\n    \"\"\"\n    @notice Function to adjust contract settings\n    @dev Requires the owner to call the function\n    \"\"\"\n    ownable._check_owner()\n\n    self.open_at = config.open_at\n    self.max_supply = config.max_supply\n\n\n@external\ndef withdraw_nfts(contract_address: address, token_ids: DynArray[uint256, 200], amounts: DynArray[uint256, 200], recipient: address):\n    \"\"\"\n    @notice Function to withdraw all tokens in the contract to a particular recipient\n    @dev Only the owner of the contract can call this\n    \"\"\"\n    ownable._check_owner()\n\n    erc1155tl: IERC1155TL = IERC1155TL(contract_address)\n    extcall erc1155tl.safeBatchTransferFrom(self, recipient, token_ids, amounts, b\"\")\n\n\n@external \ndef set_paused(pause: bool):\n    \"\"\"\n    @notice Function to pause/unpause the contract\n    \"\"\"\n    ownable._check_owner()\n\n    if (pause):\n        pausable._pause()\n    else:\n        pausable._unpause()\n\n\n@view\n@external\ndef get_input_config(contract_address: address, token_id: uint256) -> uint256:\n    return self.input_amounts[contract_address][token_id]\n    \n\n@view\n@external\ndef supportsInterface(interface_id: bytes4) -> bool:\n    return interface_id in SUPPORTED_INTERFACES\n    \n", "sha256sum": "0d17a13d2d051c2298bc9c07721c4108c4e1d8e5c723063e613373efdaa5cd99"}}, "settings": {"outputSelection": {"src/send_and_receive_editions.vy": ["*"]}, "search_paths": [".venv/lib/python3.13/site-packages", "."]}, "compiler_version": "v0.4.1+commit.8a93dd27", "integrity": "560378fa914cf660d85bbcd39b7c6ccd8f36b39067347c1b47011029456fa347"}
